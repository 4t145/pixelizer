use serde_json;
type Pallete = Vec<[u8;4]>;

pub fn get_pallete(path:&std::path::Path) -> Result<Pallete, String>{
    use std::fs::*;
    let pallete_file = read(path).map_err(|e|
        format!("ERROR: 打开pallete: {} 时发生错误, {}", path.to_str().unwrap(), e)
    )?;
    let v32:Vec<&str> = serde_json::from_slice(&pallete_file).map_err(|e|
        format!("ERROR: 解析pallete: {} 时发生错误, {}", path.to_str().unwrap(), e)
    )?;
    let mut pallete= Vec::<[u8;4]>::with_capacity(v32.len());
    for s in v32 {
        let v = u32::from_str_radix(s.trim_matches('#'), 16).map_err(|e|
            format!("ERROR: 解析pallete: {} 时发生错误, 无法解析颜色:{}, {}", path.to_str().unwrap(), s, e)  
        )?;
        pallete.push( 
            if v<=0x00ffffff {
                let [_, r,g,b]=v.to_be_bytes();
                [r, g, b, 0xff]
            } else {
                let [r,g,b,a]=v.to_be_bytes();
                [r, g, b, a]
            }
        );
    }
    Ok(pallete)
}

// const COLORTABLE:[[u8;4]; 31] = [
//     [0xff, 0x98, 0xc3, 0xff],
//     [0xf7, 0x63, 0x73, 0xff],
//     [0xd2, 0x4c, 0xab, 0xff],
//     [0xeb, 0x35, 0x32, 0xff],
//     [0xc8, 0x19, 0x16, 0xff],
//     [0x2d, 0x2d, 0x35, 0xff],
//     [0xf8, 0xd0, 0x9f, 0xff],
//     [0xf3, 0xeb, 0x26, 0xff],
//     [0xff, 0xbf, 0x1f, 0xff],
//     [0xf7, 0x6c, 0x29, 0xff],
//     [0xe1, 0xda, 0xc7, 0xff],
//     [0xf0, 0xef, 0xed, 0xff],
//     [0x52, 0xcb, 0xb8, 0xff],
//     [0x71, 0xaf, 0x1e, 0xff],
//     [0x3f, 0xd4, 0x56, 0xff],
//     [0x17, 0x87, 0x3d, 0xff],
//     [0x09, 0x6a, 0x3d, 0xff],
//     [0x98, 0x98, 0xa0, 0xff],
//     [0x36, 0xad, 0xe5, 0xff],
//     [0x22, 0x6b, 0xdc, 0xff],
//     [0x1d, 0x40, 0xa8, 0xff],
//     [0x79, 0x69, 0xcc, 0xff],
//     [0xa4, 0x62, 0x40, 0xff],
//     [0x65, 0x2f, 0x23, 0xff],
//     [0x24, 0x2f, 0x4d, 0xff],
//     [0xe3, 0xb7, 0xb6, 0xff],
//     [0xba, 0xb7, 0xe4, 0xff],
//     [0x82, 0xc3, 0xe9, 0xff],
//     [0xf8, 0xbc, 0x1d, 0xff],
//     [0x43, 0x45, 0x51, 0xff],
//     [0x4a, 0x1f, 0x7b, 0xff]
// ];